//#include "test_runner.h"

#include <vector>
#include <utility>
#include <iostream>
#include <stdexcept>

using namespace std;

// Реализуйте здесь шаблонный класс Table

template<class T>
class Deque {
public:
	Deque() {

	}
	bool Empty() const {
		return v_back.empty() && v_front.empty();
	}
	size_t Size() const {
		return v_back.size() + v_front.size();
	}
	void PushFront(T new_item) {
		v_front.push_back(new_item);
	}
	void PushBack(T new_item) {
		v_back.push_back(new_item);
	}
	T& Front() {
		return v_front.back();
	}
	const T& Front() const {
		return v_front.back();
	}
	T& Back() {
		return v_back.back();
	}
	const T& Back() const {
		return v_back.back();
	}
	T& operator[] (size_t index) {
		if (index <= v_front.size()) {
			return v_front[v_front.size() - 1 - index];
		}
		else {
			return v_back[index - v_front.size()];
		}
	}
	const T& operator[](size_t index) const {
		if (index < v_front.size()) {
			return v_front[v_front.size() - 1 - index];
		}
		else {
			return v_back[index - v_front.size()];
		}
	}
	T& At(size_t index) {
		if (index >= Size()) {
			throw out_of_range("last element is " + to_string(Size() - 1));
		}
		return operator[](index);
	}
	const T& At(size_t index) const{
		if (index >= Size()) {
			throw out_of_range("last element is " + to_string(Size() - 1));
		}
		return operator[](index);
	}
private:
	vector<T> v_back;
	vector<T> v_front;
};

/*
void TestTable() {
  Table<int> t(1, 1);
  ASSERT_EQUAL(t.Size().first, 1u);
  ASSERT_EQUAL(t.Size().second, 1u);
  t[0][0] = 42;
  ASSERT_EQUAL(t[0][0], 42);
  t.Resize(3, 4);
  ASSERT_EQUAL(t.Size().first, 3u);
  ASSERT_EQUAL(t.Size().second, 4u);

  Table<int> t2(3,3);
  t2.Resize(5, 5);
  ASSERT_EQUAL(t2[4][4], 0);
  Table<string> t3(3,3);
  t3.Resize(5, 5);
  ASSERT_EQUAL(t3[4][4], "");
  Table<vector<int>> t4(3,3);
  vector<int> empty_v;
  t4.Resize(5, 5);
  ASSERT_EQUAL(t4[4][4], empty_v);
}*/

/*
int main() {
  //TestRunner tr;
  //RUN_TEST(tr, TestTable);
  return 0;
}*/
